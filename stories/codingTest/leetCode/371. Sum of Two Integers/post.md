4비트에서
7은 0111이고 -7은 1001이다. 더하면 10000이 된다.
4는 0100이고 -4는 1100이다. 더하면 10000이 된다.
3은 0011이고 -3은 1101이다. 더하면 10000이 된다.  
전부다 10000이네?
 
8비트에서
1은  00000001이고 -1은 11111111이다. 더하면 10000000이 된다.
10은 00001010이고 -10은 11110110이다. 더하면 100000000이 된다


즉 보수란 비트연산에서 max비트 1을 만드는 행위이고
2진법이라 2의 보수인거다
그리고 그걸 구하는 방법이 


💡 코드 설명
cpp
Copy
Edit
int getSum(int a, int b) {
    while (b != 0) {
        unsigned carry = (a & b) << 1;  // 자리 올림 계산
        a = a ^ b;  // 자리 올림 없는 합 계산
        b = carry;  // 자리 올림 처리
    }
    return a;
}
a ^ b: 자리 올림 없는 덧셈 (1+0 or 0+1 → 1, 1+1 or 0+0 → 0)

(a & b) << 1: 자리 올림 발생 위치 (1+1일 때만 carry 발생)

b가 0이 될 때까지 반복 → 최종 결과는 a + b

이게 가능한 이유는 2의 보수로 음수도 비트 연산이 일관되게 동작하기 때문이야. 만약 다른 방식(예: 부호+절댓값)으로 음수를 표현했다면 이런 방식은 안 됐을 거야.

