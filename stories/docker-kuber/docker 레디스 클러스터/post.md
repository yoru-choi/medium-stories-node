window에서 docker pull을 해서 클러스터링을 하는법

docker pull redis

pull을 했을경우 이미지를 다운로드 하기때문에 아래 명령어를 사용하면 이미지가 보인다
docker images

클러스터링을 할예정이기때문에 7000, 7001, 7002를 기준으로 한다 먼저 네트워크를만든다
클러스터링을 한다는거 자체가 네트워크로 분배한다는 개념으로 접근하면 된다.
docker network create redis-cluster

도커 런을 할건데 d로 백그라운드 실해앟ㄹ거고 --name을 설정해 이름을 정할것이며 --net을 통해 방금 만든 네트워크명을 넣어 네트워크를 설정한다
그밑에 -v는 볼륨을 선택하는것이며 local의 redis.conf를 docker내의 redis.conf에 마운트 하는과정이다
p는 포트설정이며 왼쪽이 도커내부 오른쪽이 외부접근 포트이기때문에 7000을 선언하고 node내에서 연결하기위한 포트를 추가하기위해 +1만을 해서 설정한다고 한다. redis:latest는 최초에 pull했던 이미지이다. redis-server를 실행하는건 가장 오른쪽의 path의 conf를 기준으로 실행한다
7001과 7002도 같이 실행한다

docker run -d --name redis-7000 --net redis-cluster -v C:\workSpace\projects\redis-cluster\7000\redis.conf:/usr/local/etc/redis/redis.conf -p 7000:7000 -p 17000:17000 redis:latest redis-server /usr/local/etc/redis/redis.conf

docker ps를 하면 3개의 실행되고 있는 redis가 보인다

아래 명령어를 통해 아래 네트워크에서 실행되고있는 3개의 redis정보를 얻어야한다
docker network inspect redis-cluster

아래 처럼 예시의 값에 컨테이너의 IPv4Address를 확인한다 3개다 확인해야한다
ip뒤의/부터는 서브넷 마스크설정이기에 제거해야한다. rediscluster는 이것을 이해하지못할수있기때문이다
"Containers": {
"IPv4Address": "172.00.0.00/16",

위의 정보로 3개의 IPv4Address를 따로 저장해라

아래 명령어는 exec를 사용해 docker내에서 it는 터미널 인터페이스를 활성화 한다는거야 거기서 redis-7000을 사용할 컨테이너로 지정하고 redis-cli를 사용해
--cluster create는 redis클러스터를 사용하겠다는의미야 레플리카는없이
docker exec -it redis-7000 redis-cli --cluster create 172.19.0.2:7000 172.19.0.3:7001 172.19.0.4:7002 --cluster-replicas 0

> > > 'docker exec -it redis-7000 redis-cli --cluster create 172.19.0.2/16:7000 172.19.0.3/16:7001 172.19.0.4/16:7002 --cluster-replicas 0'

끝났다면 아래를 실행해
-c는 클러스터의 표시야 접근 포트도 설정해야해 안하면 기본 포트로 갈수있으니까
docker exec -it redis-7000 redis-cli -c -p 7000

접근하면 redis cli에 접근해
set foo bar
get foo
하면 bar이 나와 이것으로 클러스터링 하는법은 종료야

클러스터의 동작방식은

Redis 클러스터에서는 특정 노드가 "메인"으로 동작하지 않습니다. 클러스터의 각 노드는 특정 해시 슬롯 범위에 대한 데이터를 독립적으로 관리하는 분산 시스템입니다. 클러스터의 동작 방식은 다음과 같습니다.

1. Redis 클러스터의 기본 구조
   Redis 클러스터는 16384개의 슬롯으로 나뉘어 있으며, 키의 해시 값을 기반으로 이 슬롯들 중 하나에 매핑됩니다.

클러스터를 생성할 때, 각 노드(7000, 7001, 7002)는 슬롯의 일부를 관리하도록 분배됩니다.
예:
7000번 노드: 슬롯 0~5460
7001번 노드: 슬롯 5461~10922
7002번 노드: 슬롯 10923~16383 2. 클러스터의 동작 방식

1. 키 저장 (SET foo bar)
   클라이언트가 SET foo bar 명령어를 보내면:
   Redis 클러스터는 foo라는 키의 해시 슬롯을 계산합니다.
   예를 들어, foo의 해시 슬롯은 12182라고 가정합니다.
   클러스터는 **12182번 슬롯을 관리하는 노드(7002)**로 요청을 라우팅합니다.
   7002번 노드가 foo와 bar 값을 저장합니다.
2. 키 조회 (GET foo)
   클라이언트가 GET foo를 요청하면:
   클러스터는 foo 키의 해시 슬롯(12182)을 계산합니다.
   12182번 슬롯을 관리하는 7002번 노드로 요청을 라우팅합니다.
   7002번 노드가 foo 값을 반환합니다.
3. MOVED 에러의 동작
   클러스터에 연결된 클라이언트가 처음 요청을 잘못된 노드(예: 7000번 노드)로 보낼 수 있습니다.
   이 경우, 클러스터는 MOVED 에러를 반환하며:
   올바른 노드의 주소(예: 172.19.0.4:7002)를 클라이언트에게 전달합니다.
   클라이언트는 해당 노드로 재요청을 보냅니다.

3) 데이터의 분산 관리
   Redis 클러스터는 분산 처리를 위해 설계되었으며, 노드 간에 데이터를 공유하지 않습니다.
   각각의 노드는 자신이 담당하는 슬롯에 대한 데이터만 관리합니다.
   따라서 7000번 노드가 7001, 7002에 데이터를 공유하는 방식은 아닙니다. 대신:
   7000번 노드는 자신이 담당하는 슬롯(0~5460)의 데이터를 관리합니다.
   7001, 7002번 노드는 각각 자신의 슬롯을 관리합니다.
4) 클러스터에서 복제본(replica)의 역할
   현재 명령어에서 --cluster-replicas 0을 사용했기 때문에 복제본이 없습니다.
   복제본을 추가하면 데이터의 고가용성이 보장됩니다:

각 마스터 노드는 하나 이상의 복제본(replica)을 가지며, 복제본은 데이터를 읽기 전용으로 동기화합니다.
마스터 노드가 다운되면 클러스터는 자동으로 복제본을 승격하여 클러스터의 안정성을 유지합니다. 5. 클라이언트가 느끼는 동작
